const fs = require("fs");
const path = require("path");
const yaml = require("js-yaml");

/**
 * Post-process generated Rust code to create proper enum implementations
 * using the newtype pattern (enum variants contain Box<Struct>)
 * 
 * This is v2 - simpler and cleaner than v1:
 * - No field duplication (enum wraps the struct)
 * - No complex field parsing needed
 * - No inline enum detection required
 * - Uses #[serde(untagged)] instead of #[serde(tag = "type")]
 * 
 * WHY V2 IS BETTER:
 * 
 * The original problem: OpenAPI generator creates TWO Rust types for each message:
 *   1. struct FlexMessage { alt_text, contents, quick_reply, sender }
 *   2. enum Message { FlexMessage { alt_text, contents, quick_reply, sender } }
 * 
 * This is pure duplication! We're defining the same fields twice.
 * 
 * V1 Solution (field duplication):
 *   - Parses all struct fields (complex!)
 *   - Copies fields into enum variant (duplication!)
 *   - Field-by-field From trait (error-prone!)
 *   - Must skip enums with inline types (incomplete!)
 * 
 * V2 Solution (newtype pattern):
 *   - enum Message { Flex(Box<FlexMessage>) }
 *   - Just wraps the existing struct - no duplication!
 *   - Simple From: Box::new(value)
 *   - Works for ALL enums - no skipping needed!
 * 
 * Usage is identical:
 *   let message: Message = flex_message.into(); // Works with both v1 and v2
 * 
 * Results:
 *   - v1: 422 lines, generates 15 enums, skips 5
 *   - v2: 200 lines, generates 20 enums, skips 0
 */

/**
 * Convert schema name to snake_case for file names
 * Handles acronyms properly (e.g., URIAction -> uri_action, not u_r_i_action)
 */
function toSnakeCase(str) {
  return str
    // Insert underscore before capital letters that follow lowercase letters
    .replace(/([a-z])([A-Z])/g, "$1_$2")
    // Insert underscore before capital letters that are followed by lowercase
    // (handles acronyms like "URI" in "URIAction")
    .replace(/([A-Z])([A-Z][a-z])/g, "$1_$2")
    .toLowerCase();
}

/**
 * Extract the actual struct name from a generated Rust struct file
 */
function getStructName(filePath) {
  if (!fs.existsSync(filePath)) {
    return null;
  }

  const content = fs.readFileSync(filePath, "utf8");
  const structMatch = content.match(/pub struct (\w+)/);
  return structMatch ? structMatch[1] : null;
}

/**
 * Generate a single enum variant using newtype pattern
 */
function generateEnumVariant(variantName, structName) {
  return `    ${variantName}(Box<models::${structName}>)`;
}

/**
 * Generate From trait implementation for newtype variant
 */
function generateFromImpl(structName, enumName, variantName) {
  return `impl From<models::${structName}> for ${enumName} {
    fn from(value: models::${structName}) -> Self {
        ${enumName}::${variantName}(Box::new(value))
    }
}`;
}

/**
 * Generate Default trait implementation
 */
function generateDefaultImpl(enumName, firstVariantName) {
  return `impl Default for ${enumName} {
    fn default() -> Self {
        Self::${firstVariantName}(Box::new(Default::default()))
    }
}`;
}

/**
 * Generate a complete enum implementation using newtype pattern
 * Returns true if generated, false if skipped
 */
function generateEnumFile(enumName, discriminatorMapping, packagePath) {
  console.log(`  Generating enum (v2) for ${enumName}...`);

  const variants = [];
  const fromImpls = [];
  const modelsDir = path.join(packagePath, "src", "models");
  const variantData = [];

  // Process each variant in the discriminator mapping
  for (const [typeName, schemaRef] of Object.entries(discriminatorMapping)) {
    const schemaName = schemaRef.split("/").pop();
    const structFile = path.join(modelsDir, `${toSnakeCase(schemaName)}.rs`);
    
    // Get the actual struct name from the file
    const actualStructName = getStructName(structFile);
    
    if (!actualStructName) {
      console.warn(`    Warning: Could not find struct file for ${schemaName}`);
      continue;
    }
    
    // Use the actual struct name as the variant name
    variantData.push({
      typeName,
      structName: actualStructName,
      variantName: actualStructName,
    });
  }

  if (variantData.length === 0) {
    console.warn(`    Warning: No variants found for ${enumName}`);
    return false;
  }

  // Generate variants and From impls
  for (const variant of variantData) {
    // Generate newtype variant
    const variantCode = generateEnumVariant(variant.variantName, variant.structName);
    variants.push(variantCode);

    // Generate From impl
    const fromImpl = generateFromImpl(variant.structName, enumName, variant.variantName);
    fromImpls.push(fromImpl);
  }

  // Generate the complete file
  const fileContent = `/*
 * LINE Messaging API
 *
 * This document describes LINE Messaging API.
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 * Generated by: https://openapi-generator.tech
 * Post-processed by: post-process-enums-v2.js
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// ${enumName} enum using newtype pattern (wraps structs in Box)
/// This is automatically generated from discriminated schemas
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ${enumName} {
${variants.join(",\n")}
}

${generateDefaultImpl(enumName, variantData[0].variantName)}

// Conversion methods from struct types to enum variants
${fromImpls.join("\n\n")}
`;

  // Write the enum file
  const enumFile = path.join(modelsDir, `${toSnakeCase(enumName)}.rs`);
  fs.writeFileSync(enumFile, fileContent, "utf8");
  console.log(`    ✓ Generated ${enumFile}`);
  return true;
}

/**
 * Main post-processing function (v2)
 */
function postProcessEnumsV2(specPath, packagePath) {
  console.log(`\nPost-processing enums (v2) for ${specPath}...`);

  // Read the original spec to find discriminators
  const yamlContent = fs.readFileSync(specPath, "utf8");
  const spec = yaml.load(yamlContent);

  if (!spec.components || !spec.components.schemas) {
    console.log("  No schemas found, skipping");
    return;
  }

  const schemas = spec.components.schemas;
  let generatedCount = 0;

  // Find all schemas with discriminators
  for (const [schemaName, schema] of Object.entries(schemas)) {
    if (schema.discriminator && schema.discriminator.mapping) {
      const wasGenerated = generateEnumFile(
        schemaName,
        schema.discriminator.mapping,
        packagePath
      );
      
      if (wasGenerated) {
        generatedCount++;
      }
    }
  }

  console.log(`  ✓ Post-processed (v2): ${generatedCount} enum(s) generated`);
}

module.exports = { postProcessEnumsV2 };

// CLI usage
if (require.main === module) {
  const args = process.argv.slice(2);
  if (args.length < 2) {
    console.error("Usage: node post-process-enums-v2.js <spec-path> <package-path>");
    process.exit(1);
  }

  postProcessEnumsV2(args[0], args[1]);
}

