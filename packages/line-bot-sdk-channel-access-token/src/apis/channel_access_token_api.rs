/*
 * Channel Access Token API
 *
 * This document describes Channel Access Token API.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`gets_all_valid_channel_access_token_key_ids`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetsAllValidChannelAccessTokenKeyIdsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issue_channel_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueChannelTokenError {
    Status400(models::ErrorResponse),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issue_channel_token_by_jwt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueChannelTokenByJwtError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`issue_stateless_channel_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IssueStatelessChannelTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_channel_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeChannelTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_channel_token_by_jwt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeChannelTokenByJwtError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_channel_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyChannelTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`verify_channel_token_by_jwt`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum VerifyChannelTokenByJwtError {
    UnknownValue(serde_json::Value),
}

/// Gets all valid channel access token key IDs.
pub async fn gets_all_valid_channel_access_token_key_ids(
    configuration: &configuration::Configuration,
    client_assertion_type: &str,
    client_assertion: &str,
) -> Result<
    models::ChannelAccessTokenKeyIdsResponse,
    Error<GetsAllValidChannelAccessTokenKeyIdsError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_client_assertion_type = client_assertion_type;
    let p_query_client_assertion = client_assertion;

    let uri_str = format!("{}/oauth2/v2.1/tokens/kid", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[(
        "client_assertion_type",
        &p_query_client_assertion_type.to_string(),
    )]);
    req_builder = req_builder.query(&[("client_assertion", &p_query_client_assertion.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChannelAccessTokenKeyIdsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChannelAccessTokenKeyIdsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetsAllValidChannelAccessTokenKeyIdsError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Issue short-lived channel access token
pub async fn issue_channel_token(
    configuration: &configuration::Configuration,
    grant_type: &str,
    client_id: &str,
    client_secret: &str,
) -> Result<models::IssueShortLivedChannelAccessTokenResponse, Error<IssueChannelTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_grant_type = grant_type;
    let p_form_client_id = client_id;
    let p_form_client_secret = client_secret;

    let uri_str = format!("{}/v2/oauth/accessToken", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_form_grant_type.to_string());
    multipart_form_params.insert("client_id", p_form_client_id.to_string());
    multipart_form_params.insert("client_secret", p_form_client_secret.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueShortLivedChannelAccessTokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueShortLivedChannelAccessTokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssueChannelTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.
pub async fn issue_channel_token_by_jwt(
    configuration: &configuration::Configuration,
    grant_type: &str,
    client_assertion_type: &str,
    client_assertion: &str,
) -> Result<models::IssueChannelAccessTokenResponse, Error<IssueChannelTokenByJwtError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_grant_type = grant_type;
    let p_form_client_assertion_type = client_assertion_type;
    let p_form_client_assertion = client_assertion;

    let uri_str = format!("{}/oauth2/v2.1/token", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_form_grant_type.to_string());
    multipart_form_params.insert(
        "client_assertion_type",
        p_form_client_assertion_type.to_string(),
    );
    multipart_form_params.insert("client_assertion", p_form_client_assertion.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueChannelAccessTokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueChannelAccessTokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssueChannelTokenByJwtError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Issues a new stateless channel access token, which doesn't have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires.
pub async fn issue_stateless_channel_token(
    configuration: &configuration::Configuration,
    grant_type: Option<&str>,
    client_assertion_type: Option<&str>,
    client_assertion: Option<&str>,
    client_id: Option<&str>,
    client_secret: Option<&str>,
) -> Result<models::IssueStatelessChannelAccessTokenResponse, Error<IssueStatelessChannelTokenError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_grant_type = grant_type;
    let p_form_client_assertion_type = client_assertion_type;
    let p_form_client_assertion = client_assertion;
    let p_form_client_id = client_id;
    let p_form_client_secret = client_secret;

    let uri_str = format!("{}/oauth2/v3/token", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = p_form_grant_type {
        multipart_form_params.insert("grant_type", param_value.to_string());
    }
    if let Some(param_value) = p_form_client_assertion_type {
        multipart_form_params.insert("client_assertion_type", param_value.to_string());
    }
    if let Some(param_value) = p_form_client_assertion {
        multipart_form_params.insert("client_assertion", param_value.to_string());
    }
    if let Some(param_value) = p_form_client_id {
        multipart_form_params.insert("client_id", param_value.to_string());
    }
    if let Some(param_value) = p_form_client_secret {
        multipart_form_params.insert("client_secret", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IssueStatelessChannelAccessTokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IssueStatelessChannelAccessTokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<IssueStatelessChannelTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Revoke short-lived or long-lived channel access token
pub async fn revoke_channel_token(
    configuration: &configuration::Configuration,
    access_token: &str,
) -> Result<(), Error<RevokeChannelTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_access_token = access_token;

    let uri_str = format!("{}/v2/oauth/revoke", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("access_token", p_form_access_token.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeChannelTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Revoke channel access token v2.1
pub async fn revoke_channel_token_by_jwt(
    configuration: &configuration::Configuration,
    client_id: &str,
    client_secret: &str,
    access_token: &str,
) -> Result<(), Error<RevokeChannelTokenByJwtError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_client_id = client_id;
    let p_form_client_secret = client_secret;
    let p_form_access_token = access_token;

    let uri_str = format!("{}/oauth2/v2.1/revoke", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("client_id", p_form_client_id.to_string());
    multipart_form_params.insert("client_secret", p_form_client_secret.to_string());
    multipart_form_params.insert("access_token", p_form_access_token.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeChannelTokenByJwtError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Verify the validity of short-lived and long-lived channel access tokens
pub async fn verify_channel_token(
    configuration: &configuration::Configuration,
    access_token: &str,
) -> Result<models::VerifyChannelAccessTokenResponse, Error<VerifyChannelTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_access_token = access_token;

    let uri_str = format!("{}/v2/oauth/verify", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("access_token", p_form_access_token.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyChannelAccessTokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyChannelAccessTokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifyChannelTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.
pub async fn verify_channel_token_by_jwt(
    configuration: &configuration::Configuration,
    access_token: &str,
) -> Result<models::VerifyChannelAccessTokenResponse, Error<VerifyChannelTokenByJwtError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_access_token = access_token;

    let uri_str = format!("{}/oauth2/v2.1/verify", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("access_token", &p_query_access_token.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyChannelAccessTokenResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyChannelAccessTokenResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<VerifyChannelTokenByJwtError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
